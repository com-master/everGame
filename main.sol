
/**
 * This file was generated by EverDev.
 * EverDev is a part of EVER OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;

enum gameTypes {city, person}
enum ways {up,down,right,left}

struct block {
    uint256 owner;
    gameTypes types;
}

struct cords {
    uint32 x;
    uint32 y;
}

// This is class that describes you smart contract.
contract main {
    uint32 lastid = 0;
    mapping(uint32=>block) public id_block;
    mapping(uint32=>cords) public id_cords;
    // Contract can have an instance variables.
    // In this example instance variable `timestamp` is used to store the time of `constructor` or `touch`
    // function call
    

    uint32 public timestamp;

    // Contract can have a `constructor` â€“ function that will be called when contract will be deployed to the blockchain.
    // In this example constructor adds current time to the instance variable.
    // All contracts need call tvm.accept(); for succeeded deploy
    constructor() public {
        // Check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and
        // message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        // The current smart contract agrees to buy some gas to finish the
        // current transaction. This actions required to process external
        // messages, which bring no value (henceno gas) with themselves.
        tvm.accept();

        timestamp = now;
    }

    function renderHelloWorld () public pure returns (string) {
        return 'helloWorld';
    }

    // Updates variable `timestamp` with current blockchain time.
    function touch() external {
        // Each function that accepts external message must check that
        // message is correctly signed.
        require(msg.pubkey() == tvm.pubkey(), 102);
        // Tells to the TVM that we accept this message.
        tvm.accept();
        // Update timestamp
        timestamp = now;
    }

    // function mapview() public view returns (){
    //     return map;
    // }
    function _move(uint32 id,ways way) public {
        tvm.accept();
        if(way == ways.right && (id_cords[id].x != 20)) {
            id_cords[id].x += 1;
        } else if (way == ways.down && (id_cords[id].y  != 20)) {
            id_cords[id].y += 1;
        } else if (way == ways.up && (id_cords[id].y != 0)) {
            id_cords[id].y -= 1;
        } else if (way == ways.left && (id_cords[id].x != 0)) {
            id_cords[id].x -= 1;
        }
    }

    function _spawn(uint32 x, uint32 y,gameTypes types) public {
        tvm.accept();
        block spawn = block(msg.pubkey(),types);
        cords cord = cords(x,y);
        id_block[lastid] = spawn;
        id_cords[lastid] = cord;
        lastid++;
    }
    function afterSignatureCheck(TvmSlice body, TvmCell message) private inline 
        returns (TvmSlice) 
    {
        return body;
    }
}
